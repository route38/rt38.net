---
title: Why I removed Java from my résumé
layout: post
description: "I bid farewell to Java on my resume.  It's today's Cobol."
---

I used to list Java on my résumé, because it's a language generally in demand
and it's relatively easy to find work doing Java.  People ignore the whole raft
of other qualifications on my resume, though, and see Java shining above them
all.  It's like looking at a plumber's handiwork in your new bathroom, and only
thinking about how much crap the toilet can handle in one flush.

The recruiters who contact me asking for a Java programmer must think it's my
first programming language, which would be worse than bad were it true, and they
must assume I'm completely incompetent in superior languages like JavaScript,
C++, and PHP.

Java is a terrible, terrible, terrible first/only programming language.  C,
though, isn't.  It's not perfect, but it is decent, rather like learning Latin
as a freshman in college before learning French later on.  C is a good first
programming language in the university context because it places the larval
programmer where she needs to be: close to the hardware.  C++ is a fine
substitute because, in truth, it's C wearing a business suit.  Any other
language – and I do mean *any other language* – divorces the programmer from the
underlying hardware, which is not a good thing when you're learning.

Programming, after all, is the art of controlling a fast and dumb machine to
make it do slow and smart things.  Programming is *all about* controlling
hardware at its most basic.

Let me put this in perspective.  Young racing drivers, when they go to Skip
Barber or some other performance driving school, are handed what amounts to a
motor on wheels with a seat, steering wheel, pedals, and gear lever.  There's
power brakes and power steering, but little else in terms of driver
amenities. You get a manual gearbox, no anti-lock brakes, no traction control,
no active suspension, no stability control.  And before you ever hit the track,
you learn all about the theory of driving a racing car: things like
slow-in-fast-out, how to handle over- and understeer, and the racing line.  If
you don't have a strong understanding of how a car handles, you have no business
calling yourself a racing driver.  Biff and Betty, when they receive their
licenses, can make the car move, make the indicators work, and park it without
destroying anything. That's it.  They're not the next Alain Prost, nor should
they feel they are. (Unless they're Jenson Button, who failed his driver's test
for parking too close to another car.)

It's scarcely different in programming.  A well-rounded programmer has that
in-depth theoretical knowledge, even if she never needs to use much of it,
because it enables her to be a better programmer.  Pointers and recursion are to
the programmer what steering and shifting are to the racing driver: concepts so
fundamental to the discipline that anybody who doesn't understand them is
powerless to do anything of significance.  If you can't correctly shift a manual
transmission, you'll never be the next Jackie Stewart.  Likewise, if you can't
grok pointers, you'll never be the next Bill Gates.

More crucially, if you don't understand the concepts of buffer overflow, stack
smashing, integer underflow, integer overflow, or return-address manipulation,
you are a danger to anyone who uses your code.  (It's actually kinda neat how
malware writers exploit misfeatures of the C language to make things happen.)
Understanding these subjects requires knowledge of computing internals that only
learning C can confer.

Java-only curricula (and their genetically malformed parents, Pascal- and
Cobol-only curricula) generate people who have no right to call themselves
programmers.  [Joel Spolsky gets this][1], because at Fog Bank Software, he has
to recruit from batches of students generated by said JavaSchools.  What the
hell are they teaching there?  How to color within the lines?  If reading [The
Daily WTF][2] is any indication, they're learning how to write atrocious code in
a language that makes it too easy to write atrocious code.

Drs. Robert Dewar and Edmond Schonberg of AdaCore [get it][3] too, because their
company has to find engineers for mission-critical high-reliability systems from
the same pool of "talent."  Their main critiques of modern CS programs, which
echo Spolsky's, are as follows:

1.  Shrinking math requirements.

2.  Vanishing "polyglot" programs in favor of special-purpose packages and large
    libraries.

3.  Insufficient skill sets, especially regarding programming for security and
    safety purposes.

Java insulates the programmer from the realities of the hardware on which she
works, which diminishes her understanding of the inner workings of the system
she *needs* to know.  In particular, she may never learn or (more importantly)
grok the importance of floating point formats.  She may never learn (or grok)
the importance of writing parallelizable code.  Most importantly, she'll
probably never even see a functional language.  (Pure-functional languages like
Haskell have no side-effects.  They're the easiest languages to write parallel
code in for that very reason.)  Java makes programming easy.  This is a great
thing if you're a professional writing your company's payroll package, but not
if you're an aspiring professional writing "Hello world" in the umpteenth
variation.  Java the language, and Java the class library, jointly place the
programmer in the plumbing aisle of a hardware store, where stringing together
the correct collection of parts yields something close to the original
requirements.  It offers no great creativity without great pain.  It offers no
room for cleverness, a problem common to all classical object-oriented
languages.  A CS degree earned only by writing Java is a degree in
computer-scientology, not computer science.

Dewar and Schonberg don't shy from offering a solution in their paper: teach
five languages. (Others are presumably optional.)

1.  C is the most important as it amounts to platform-independent
    assembler. Give me a mound of C sources and `gcc -S`, and I can see the very
    plain effects of compiler optimization.  Add a programmer's manual for the
    processor and a computer architecture class, and I'll start to see the true
    cost of every statement.

2.  C++ drags C into the 21st century by adding the features of object
    orientation, and it still forces you to do your memory management manually.

3.  Lisp is the gateway drug to the world of functional programming.  In their
    words, "a functional, stateless style is clear, natural, easy to understand,
    and efficient to boot."  It's also (as I alluded above) easy to parallelize,
    and because of its outstanding referential transparency, Lisp is easy to
    self-define -- that is, you can easily write a Lisp compiler in plain Lisp.

4.  I hate Java as a first/only language, but it is an important language to
    learn later in the curriculum.  I will give Java the nod for easy threads (a
    subject I still feel should be taught in C/C++ with pthreads) and an amazing
    reflection library.

5.  Ada is the language software engineers *par excellence* use for systems that
    just have to work.  If you took the subway to work this morning, software
    written in Ada made sure you didn't crash into another train and that you
    arrived at the destination on time.  If you flew out to Google I/O this
    year, software written in Ada kept the airplane on course and, for that
    matter, airborne.  If you wear a pacemaker, software written in Ada keeps
    your heart beating -- literally.  If you drive a car, software written in
    Ada controls the throttle response, ignition advance, traction control,
    anti-lock brakes, electronic differential, automatic transmission, and
    anything else that could kill you or cause great harm if it were to fail.

Scripting languages are fantastic technology and they make programming very fun
for someone who learned it the hard way.  Getting to write your final programs
in Ruby or Python your senior year should be a reward for toughing it out with
C, not the gateway drug to computer programming.  Programming is one of the most
complex manifestations of human endeavor.  Scripting languages let the
programmer focus on the problem, not the alleged solution.  For that reason,
they're a luxury and a privilege, not learning tool or a right.  You write
Twitter in Ruby, not the Linux it runs on.

If you look at the C++ STL and say, "Well there's already an implementation of a
sort method here, so why should I make the students write their own," you are
not just *part* of the problem; you *are* the problem.  If a CS program gets
across only *nine* main points, they should be these.

1.  Programming is neither glamorous nor romantic.

2.  Learn why you shouldn't represent financial calculations in floating point.

3.  C is the lowest common denominator.  If you don't know C, you're useless.

4.  If you can't test your own code, you're worse than useless.

5.  Everything you use, from the biggest mainframe to the smallest smartphone,
    has at least two processor cores.  It pays to have at least a vague idea of
    multiprocessing and threading.

6.  A foundation in mathematics is of vital importance.  In particular, it pays
    to know calculus, linear algebra, number theory, set theory, and the very
    special math of computer science (indeed, its theoretical backbone),
    computation theory.  It also helps immensely to know binary, octal, and
    hexadecimal numbering systems, as they are ubiquitous.

7.  Any framework, library, or tool you learn now will be at least partly
    outdated by the time you graduate.

8.  For that reason, do not teach frameworks, do not use "hip" tools, and teach
    algorithms and axioms first and foremost.  Use time-tested tools like vim,
    GCC, SQLite, Mozilla, and Linux for teaching the basics.  Students can move
    on to BBEdit, Xcode, MySQL, Chrome, and Mac OS X when they've graduated.

9.  Working solo is great fun, but no project in the real world happens in a
    vacuum.  Team projects are of vital importance, as is learning *how* to use
    others' libraries and APIs.  Reading documentation is a subtle art.  Working
    well with others is an even subtler art.

Back to those topics at the head of this article: pointers and recursive
methods.  Pointers are the most fundamental level of abstraction in programming,
and how anybody could fail to understand them is utterly beyond me.  Once you
"get it," pointers are easy.  Of course, once you "get it," recursion is easy as
well.

And here's the thing: working in raw pointers isn't necessary in the vast
majority of code written today.  Embedded programmers do it, as do the few
operating system programmers of the world.  If you wish to contribute to the
Linux kernel, a very strong knowledge of C is the most essential thing you can
have.  If you wish to contribute to the WebKit project, a very strong knowledge
of C's bastard child C++ is the most essential thing you can have.  The Java
Virtual Machine all the cool kids are fond of?  Yeah, that's written in
C. Python?  Its interpreter is written in C.  PHP?  Same thing.  And if you want
to extend PHP yourself, you write the extension in (you guessed it) C.

My father, who used to build houses for a living, continues to differentiate
between a true carpenter and (his words) a "wood butcher."  In IT, we
differentiate between programmers and [code grinders][4].  The distinction is
exactly the same: craftsmen versus laymen.  There are programmers, and then
there are Programmers.

Here's the fact of the matter.  I have a degree in computer science.  That makes
me, by default, a computer scientist.  There are some things, though, that must
qualify that statement.  The need for such qualifications permits me to say some
things about computer science and its practitioners.

* If you do not know C, you are not a computer scientist.

* If you do not understand pointers, you are not a computer scientist.

* If you do not understand recursion, you are not a computer scientist.

* If you do not understand the concepts of functional programming, you are not a
  computer scientist.

* If you do not understand (at least the basics of) probability, number theory,
  or set theory, you are not a computer scientist.

* If you do not understand the theory of computation, you are not a computer
  scientist.

Because part and parcel of computer science is programming computers, I also
happen to be a programmer.  Again I must qualify that statement; that allows me
to say some things about programming and its practitioners.

* [If you do not understand
    pointers](http://thedailywtf.com/Articles/Lucky-Pointing.aspx), you are not
    a programmer.

* If you do not understand recursion, you are not a programmer.

* [If you do not understand abstraction generally][5], you are not a programmer.

* [If you do not understand conditionals][6] (and cannot use them correctly as a
  result), you are not a programmer.

* [If you do not understand subroutines][7], you are not a programmer.

* [If you do not understand basic data structures][8], you are not a programmer.

* [If you do not understand arrays][9], you are not a programmer.

* [If you do not understand loops][10], you are not a programmer.

* [If you do not understand regexen][11], you are not a programmer.

* [If you do not know how to RTFM][12], you are not a programmer.

* If you are working in an object-oriented system, and ever [do something like
  this][13], you are not a programmer.

* [If you cannot bit-bash][14], you are not a programmer.

* If the only language you know is one of Java, Cobol, C#, PHP, Ruby,
  JavaScript, Python, Pascal, or Perl, you are not a programmer.  They're
  mostly decent languages (especially Ruby and Python), but they don't make a
  real programmer without a foundation in C.

A lot of this comes down to a couple of truths.  Good programmers know their
tools and how they let them access the theory they know.  They also appreciate
programming humor, like the ancient joke: "Why do computer scientists confuse
Halloween and Christmas? Because Oct 31 = Dec 25," and seeing "Did you mean:
*recursion*" when Googling "recursion" makes them chuckle.  (Every damn
time. That always gets me.)

C is my favorite programming language because of the power and command it gives
me over the hardware.  It's also my least favorite because of the biblical
amount of bookkeeping it compels me to do.  It saddens me to know that many CS
graduates of today will never know that particular dichotomy.

That's why, after much thinking and internal debate, I removed Java from my
résumé.  Java is today's Cobol.  Need I say more?

[1]: http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html
[2]: http://thedailywtf.com
[3]: http://www.crosstalkonline.org/storage/issue-archives/2008/200801/200801-Dewar.pdf
[4]: http://www.catb.org/jargon/html/C/code-grinder.html
[5]: http://thedailywtf.com/Articles/14-Layers-Deep.aspx
[6]: http://thedailywtf.com/Articles/PickaState.aspx
[7]: http://thedailywtf.com/Articles/Thourough-Username-Validation.aspx
[8]: http://thedailywtf.com/Articles/The-Shortcut-Guy.aspx
[9]: http://thedailywtf.com/Articles/Have-you-Tried-Arrays.aspx
[10]: http://thedailywtf.com/Articles/Reusable-Code.aspx
[11]: http://thedailywtf.com/Articles/How-to-Extract-Text-from-HTML-(Experts-Only).aspx
[12]: http://thedailywtf.com/Articles/Denumerating-the-DayOfWeekEnum.aspx
[13]: http://thedailywtf.com/Articles/Generic_Generics.aspx
[14]: http://thedailywtf.com/Articles/A-Bit-Misguided.aspx
