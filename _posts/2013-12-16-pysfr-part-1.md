---
layout: post
title: "PYSFR Part 1: Intro &amp; Inventory"
mood: "wanting to be the best, like no one ever was"
music: "&ldquo;Gym Leader Battle&rdquo; &mdash; <em>Pok&eacute;mon HeartGold/SoulSilver OST</em>"
description: "Reading fifteen-year-old video game saves: how hard can it be?"
---
The video game world changed considerably in 1998 with the North American release of a modern role-playing classic in the original Pok&eacute;mon titles, _Pok&eacute;mon Red Version_ and _Pok&eacute;mon Blue Version_.  A third version followed in 1999, rather appropriately called the _Yellow Version_ after its mascot.  The goal of the games was simple: capture and train wild animals and use them for contests called "battles," whereby one worked one's way up the various tiers of competition and sought no less than being the champion trainer.

The games captured the minds and hearts of many in my generation, myself included.  In the nearly 16 years hence, the games have spawned a trading card game, hundreds of toys, five direct sequels, upward of 50 related games for every Nintendo console bar the NES and SNES, a television series that has run for more than 800 episodes, hundreds of chapters of manga, and sixteen feature films.  The games themselves were inevitably dumped to the PC and dissected down to the byte level; with the concomitant dump came the very fascinating process of reverse engineering.  The games have now been disassembled and documented, and I figured it was high time to throw my hat into the ring, use the ad hoc specifications that exist, and write my own program to decode the games' battery-backed save data.  This data resides in a 32768-byte file using a proprietary character encoding, big-endian arithmetic, and a tightly packed binary format.

So, I ask:  How hard can it be to decipher that data?  The answer: not very, if you're using C++.

In these games, the player can carry up to 20 items in his backpack; this pack contains everything from healing items to a foldable bicycle and game map.  Each item in this list is stored in a simple fashion: by a hexadecimal identifier indicating what item, followed by the quantity, and the list is terminated by 0xFF.  Since we know the maximum length of the inventory and its location offset within the save file, it's an easy matter to get the inventory data using `memcpy`.  First, we want the inventory size:

{% highlight c++ %}
uint read_pack_inv_size() {
   uchar sz = save_file[0x25C9];
   return (uint) sz;
}
{% endhighlight %}

The size is stored as a single byte and we just want to get the value and return it as an unsigned integer.  We use that size to inform how we read the inventory.  We start with an extremely simple class:

{% highlight c++ %}
class pack_item {
public:
   uchar quantity, id;

   pack_item(uint offset);
   void print(uint offset);
};
{% endhighlight %}

Then we implement the methods for this class:

{% highlight c++ %}
pack_item::pack_item(uint off) {
   uint offset = beginning_offset + 2 * off;
      
   this->quantity = save_file[offset + 1];
   this->id = save_file[offset];
}

void pack_item::print(uint offset) {
   printf("  %02d. %-15s x%d\n", offset, item_decode(this->id), this->quantity);
}
{% endhighlight %}

Then, in `main`, we only have to do the reading:

{% highlight c++ %}
   uint pack_size = read_pack_inv_size();
   vector<pack_item *> *inventory = new vector<pack_item *>();
   
   for(int i = 1; i <= pack_size; i++) {
      inventory->push_back(new pack_item(i));
   }
   
   printf("Inventory:\n");
   
   for(int i = 0; i < inventory->size(); i++) {
      inventory->at(i)->print(i + 1);
      delete inventory->at(i);
   }

   delete inventory;
{% endhighlight %}

There's not anything overly complex here, just standard loops and so forth.  That's the essence of good programming in my opinion: that you can express an idea in a simple fashion.  Tomorrow, I'll go over the weird character set and how I read it.