---
layout: post
title: "PYSFR Part 4: Interpreting Party Data"
mood: "here for the Party"
music: "&ldquo;Route 38/39&rdquo; &mdash; <em>Pok&eacute;mon HeartGold/SoulSilver OST</em>"
description: "Learn about the bits and bytes that make up your digital friends."
---
This week, we've been digging into the battery-backed save files from the original _Pok&eacute;mon_ games.  On Monday, we saw how easy it was to read the contents of the player's [inventory][0], and on Tuesday we dissected the weird [character set][1] used by the games.  Yesterday, we briefly investigated the process of [decoding][2] byte identifiers into Pok&eacute;mon, items, moves, and types.  I'm going to spend today and tomorrow deciphering the party data.  Today is all about the data structure I use to make it possible.

[0]: /2013/12/pysfr-part-1
[1]: /2013/12/pysfr-part-2
[2]: /2013/12/pysfr-part-3

I start with a very simple C++ class.  I find it pointless to think of it in terms of accessor methods or whatever other bullshit they teach you in school -- that would only add unnecessary overhead to a simple program.

{% highlight c++ %}
class party_pkmn {
public:
   uchar index;
   ushort health;
   uchar pc_level;
   uchar status_ailment;
   uchar type1;
   uchar type2;
   uchar catch_rate;
   uchar move1_index;
   uchar move2_index;
   uchar move3_index;
   uchar move4_index;
   ushort ot;
   uint exp;
   ushort healthEV;
   ushort attackEV;
   ushort defenseEV;
   ushort speedEV;
   ushort specialEV;
   ushort dv;
   uchar move1_pp;
   uchar move2_pp;
   uchar move3_pp;
   uchar move4_pp;
   uchar level;
   ushort max_health;
   ushort attack;
   ushort defense;
   ushort speed;
   ushort special;
   uchar *name;

   party_pkmn(uint offset);
   ~party_pkmn();
   void print();
};
{% endhighlight %}

I keep everything unsigned here so I don't have to worry about sign bits or any of the problems they cause.  What's more, the games themselves use unsigned arithmetic because the speed boost is significant for a Z80 processor.  So let's go through the fields, as documented [on Bulbapedia][3] and now here too.

[3]: http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_data_structure_in_Generation_I

The index number is the byte identifying which of the 151 Pok&eacute;mon this record identifies.  The health field records the current amount of hit points the Pok&eacute;mon has, out of the maximum defined in `max_health`.  The `status_ailment` byte stores status ailments such as sleep and poison in packed binary: a value of 0x04 signifies sleep, 0x08 poison, 0x10 burn, 0x20 freezing, and 0x40 paralysis.  The transient conditions of bad poison and confusion are restricted to battle and so are not stored in that field.

The Pok&eacute;mon's elemental types are stored in `type1` and `type2`, which might seem redundant since those bytes are stored in the game ROM itself.  The `catch_rate` byte stores a value between 0 and 256 that gives the probability of capturing the Pok&eacute;mon.  In the second-generation games, this field is used for storing the item the Pok&eacute;mon holds; this was taken advantage of for having certain Pok&eacute;mon holding items when traded up from first-generation games.

The move indices indicate the moves known by the Pok&eacute;mon, or 0x00 if no move is known for that slot.  A maximum of four moves may be known, and they have a certain number of permissible uses, called "Power Points," stored in the `moveN_pp` fields for N between 1 and 4.

Experience in the game is stored as a 24-bit unsigned big-endian integer.  The highest ordinary value experience can take is 1250000, but overflowing this field with certain Pok&eacute;mon can result in an underflow glitch.

"Effort values" are how the game tracks earned experience for translating it into gains in stats.  A Pok&eacute;mon has five stats in the first generation: health, attack, defense, special, and speed.  Actual stats are calculated based on a Pok&eacute;mon's base stats, level, effort values, and diversification values.  DVs are a packed two-byte quantity with each nybble representing one of the base stats aside from health.  (Health gets its own DV in Generation 3 and beyond.)  The DV for health is calculated by bitwise OR of the high bits of each nybble.

The name of the Pok&eacute;mon is stored as a standard string up to 11 characters long and terminated by 0x50.

It's a simple matter of reading in the fields from the save file and given the offset and known party size, we can read out all this information.  We'll do that tomorrow to round out the week.

The trainer ID stored in `ot` is self-explanatory: it represents the ID of the trainer who caught the Pok&eacute;mon.  If this differs from the trainer ID of the player, then the Pok&eacute;mon is considered an outsider.

Tomorrow, I'll cover actually reading this data via a C++ routine.