---
layout: post
title: "PYSFR Part 5: Interpreting Party Data, Part 2"
mood: "here for the Party again"
music: "&ldquo;Champion Battle&rdquo; &mdash; <em>Pok&eacute;mon Diamond/Pearl OST</em>"
description: "Learn more about the bits and bytes that make up your digital friends."
---
This week, I've been going over some of the implementation details behind a little project of mine for decoding old Pok&eacute;mon Yellow game save files.  On Monday, I went over the motivation behind the project and the simple task of [reading the character's inventory][0].  Tuesday saw a description of the vaguely ASCII-like [character set][1], while on Wednesday I discussed [turning byte identifiers into meaningful names][2].  Finally, yesterday, I discussed [how party Pok&eacute;mon data is structured][3]; that means that today, we're going to round it out by actually reading the character data into the party member class.

[0]: /2013/12/pysfr-part-1
[1]: /2013/12/pysfr-part-2
[2]: /2013/12/pysfr-part-3
[3]: /2013/12/pysfr-part-4

This is as easy as using some [unions][4] to do our byte-swapping and using everything we've learned to decode and print out the data.

[4]: /2013/12/unions

For what it's worth, the two unions are as follows:

{% highlight c++ %}
typedef union _mkshort {
   uchar data[2];
   ushort value;
} mkshort;

typedef union _mkint {
   uchar data[4];
   uint value;
} mkint;
{% endhighlight %}

This is the result we're after:

    Party Pokemon #0
      NAME:   A-Bugs
      Index:  0xbd (Weepinbell)
      HP:     0x0 (0)
      Status: 0x0
      Type1:  0x16 (Grass)
      Type2:  0x3 (Poison)
      Rate:   0xff
      Move 1: Acid         (24+0 PP)
      Move 2: Cut          (30+0 PP)
      Move 3: Sleep Powder (13+0 PP)
      Move 4: Mega Drain   (4+0 PP)
      OT ID:  57168
      EXP:    20321 (F: 29  MF: 27  S: 25  MS: -1)
      EVs:   (1910, 2389, 2296, 2183, 2303)
      DVs:    9/1/12/2/7 (0x1c27)

This data structure is 44 bytes long, and I do most of my thinking in hexadecimal during this routine, so if hex makes you squeamish, I suggest you stop reading now.

### But hex doesn't make me squeamish

Without further ado, we start with a little housekeeping.

{% highlight c++ %}
party_pkmn::party_pkmn(uint offset) {
   offset -= 1;
   uchar data[0x2c];
   mkshort health, ot, health_ev, attack_ev, defense_ev, speed_ev, special_ev, dv;
   mkint exp;

   memcpy(data, save_file + offset * 0x2c + 0x2f34, 0x2c);
{% endhighlight %}

With `memcpy` at your side, you can do anything.  After reading the game file into memory (at `save_file`, a global), all we have to do is start reading from a known offset.

Then it's a simple matter of moving data into the class's fields.

{% highlight c++ %}
   this->index = data[0];

   health.data[0] = data[2];
   health.data[1] = data[1];
   this->health = health.value;
{% endhighlight %}

Any two-byte quantity has to be byte-swapped, and this is how we do it -- put the low byte in first, then the high byte.  For experience, which is a 24-bit quantity, we simply set the highest byte to zero:

{% highlight c++ %}
   exp.data[0] = data[16];
   exp.data[1] = data[15];
   exp.data[2] = data[14];
   exp.data[3] = 0;
   this->exp = exp.value;
{% endhighlight %}

I don't calculate the DV for hit points until I run the output routine.  Names are stored elsewhere in memory, and reading them is easy:

{% highlight c++ %}
   this->name = pkmn_to_ascii_range(offset * 0x0b + 0x307e, 0x0b);
{% endhighlight %}

So, in `party_pkmn::print`, to get the health DV we have to bit-bash:

{% highlight c++ %}
   attack  = (this->dv & 0xf000) >> 12;
   defense = (this->dv & 0x0f00) >> 8;
   speed   = (this->dv & 0x00f0) >> 4;
   special =  this->dv & 0x000f;
   health  = ((attack  & 1) * 8) + 
             ((defense & 1) * 4) +
             ((speed   & 1) * 2) +
              (special & 1);
{% endhighlight %}

The added benefit of doing this bit-bashing is that we can get the values of each individual DV from the packed short, and so we can simply display them using `printf`.  (The C++ way of using `cout` and `std::hex` didn't much appeal to me.  That's the nice thing about C++ -- if there's a feature you don't like, you can use the C version instead. :bowtie:)

One note: Power Point[^1] values for moves are stored in a packed format with the lower six bits representing the number of Power Points and the high two bits representing the number of PP UP items used by the player to increase them.  The game translates this into an actual PP count ranging between 5 and 56 depending on the move and the number of PP UP items used on each.

Decoding this isn't exactly tricky; you just need the right bitmasks and shifts:

{% highlight c++ %}
   uchar move1_pp = this->move1_pp & 0x3f;
   uchar move2_pp = this->move2_pp & 0x3f;
   uchar move3_pp = this->move3_pp & 0x3f;
   uchar move4_pp = this->move4_pp & 0x3f;

   uchar move1_ppup = (this->move1_pp & 0xc0) >> 6;
   uchar move2_ppup = (this->move2_pp & 0xc0) >> 6;
   uchar move3_ppup = (this->move3_pp & 0xc0) >> 6;
   uchar move4_ppup = (this->move4_pp & 0xc0) >> 6;
{% endhighlight %}

So there you go.  The full routines are in `party_pkmn.cc` in the full source distribution for PYSFR, which is available at <http://github.com/tnwae/pysfr>.  The program is licensed under the terms of the Do What the Fuck You Want To Public License, version 2.0, with the accompanying manual licensed under CC-0.

[^1]: Let's see how many more Microsoft product names I can inadvertently cram into one paragraph. :wink: