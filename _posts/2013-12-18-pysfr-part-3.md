---
layout: post
title: "PYSFR Part 3: Decoders"
mood: "no kill like overkill"
music: "&ldquo;Team Rocket Battle&rdquo; &mdash; <em>Pok&eacute;mon HeartGold/SoulSilver OST</em>"
description: "Because hash tables are overrated."
---
Everything in a first-gen Pok&eacute;mon game save file is stored as a single-byte identifier.  There are five primary kinds of such identifiers: characters (discussed [yesterday][0]), Pok&eacute;mon, items (inventory format discussed [Monday][1]), elemental types, and the individual moves each Pok&eacute;mon knows.  Tomorrow and Friday, I'll discuss deciphering the data structure behind party Pok&eacute;mon, but for today I'm taking it easy by discussing how I decode identifiers into names.

[0]: /2013/12/pysfr-part-2
[1]: /2013/12/pysfr-part-3

Each Pok&eacute;mon has one or two elemental types, and the moves they can use have types as well.  The elemental types determine what sorts of attacks are strong or weak against a respective Pok&eacute;mon.  There were fifteen types in the first series of games:

{% highlight c++ %}
char *type_decode(uchar type) {
   switch(type) {
      case 0x00: return "Normal";    // Giga Impact!
      case 0x01: return "Fighting";  // Submission!
      case 0x02: return "Flying";    // Hurricane!
      case 0x03: return "Poison";    // Cross Poison!
      case 0x04: return "Ground";    // Earthquake!
      case 0x05: return "Rock";      // Stone Edge!
      case 0x07: return "Bug";       // Megahorn!
      case 0x08: return "Ghost";     // Shadow Ball!

      // big jump for special types.
      case 0x14: return "Fire";      // V-create!
      case 0x15: return "Water";     // Water Spout!
      case 0x16: return "Grass";     // Wood Hammer!
      case 0x17: return "Electric";  // Thunder!
      case 0x18: return "Psychic";   // Psystrike!
      case 0x19: return "Ice";       // Blizzard!
      case 0x1a: return "Dragon";    // Spacial Rend!

      // error handler.
      default: return "Bird";        // Missingno!
   }
}
{% endhighlight %}

Here, I've included the name of the most powerful attack of that type, up-to-date as of the fifth generation.  (The name of Spacial Rend makes me sic.)  This decoder shows the basic flow of the rest: I look at the byte, provide a list of valid values, and give a default for invalid ones.  I initially wrote this program in C, and this is perfectly valid in C and C++, although it gives a warning when I build it in C++, because returning constant strings is deprecated behavior.  When you compile this code, the compiler generates a jump table, and calling the routine results only in an array lookup -- which is very fast.

An alternate way of doing this would be to create an array -- since all these identifiers are one byte wide, the length of the array would be capped at 256 entries -- and use the indices of the array to reference the value.  This is a bit of a bother in C++, since C++ lacks hash literals and the other way of doing it -- reading in the values from a file -- seems like overkill.  (Maybe I need to rewrite it in Python?)  (All it'd take would be some CSV files.)