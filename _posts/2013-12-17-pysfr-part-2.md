---
layout: post
title: "PYSFR Part 2: Character Set"
mood: "ready to go, what else?"
music: "&ldquo;Rival Battle&rdquo; &mdash; <em>Pok&eacute;mon HeartGold/SoulSilver OST</em>"
description: "Why couldn't the designers of the first-gen Pok&eacute;mon games use ASCII like everyone else?"
---
[Yesterday](/2013/12/pysfr-part-1), I discussed the inventory-reading part of my program to read old Pok&eacute;mon game saves.  That was a relatively easy bit of code to discuss, and the character set isn't too much harder.  The designers used a proprietary character set for reasons known only to them; other game developers did opt to use ASCII on the Game Boy.  Nonetheless, we can do the necessary byte-bashing to get the characters into a readable form.

We start with the easiest part: upper- and lowercase letters.

| Letter | Hex  | Dec |
|--------|-----:|----:|
| A      | 0x80 | 128 |
| ...    | ...  | ... |
| Z      | 0x99 | 153 |
| a      | 0xA0 | 160 |
| ...    | ...  | ... |
| z      | 0xB9 | 185 |

The case ranges are separated by punctuation characters.  Running `man ascii` to get an ASCII table and doing a little hexadecimal arithmetic revealed that a naive conversion could simply subtract 0x3F from the Pok&eacute;mon character to get to ASCII, since six characters separate the range just as in ASCII:

{% highlight c++ %}
uchar pkmn_to_ascii_char(uchar pkmn_char) {
   return pkmn_char - 0x3f;
}
{% endhighlight %}

For the remaining characters, you have to use a conversion table:

| Symbol      | Hex      | Dec     |
|-------------|---------:|--------:|
| `<Null-0>`  | 0x00     | 0       |
| `<End-80>`  | 0x50     | 80      |
| `<Space>`   | 0x7F     | 127     |
| (           | 0x9A     | 154     |
| )           | 0x9B     | 155     |
| :           | 0x9C     | 156     |
| ;           | 0x9D     | 157     |
| [           | 0x9E     | 158     |
| ]           | 0x9F     | 159     |
| Ã©           | 0xBA     | 186     |

This is a truncated version of the conversion table in `Manual.md` from the PYSFR distribution.  The terminator for strings is 0x50 instead of 0x00, which I use when converting a Pok&eacute;mon string into an ASCII one:

{% highlight c++ %}
uchar *pkmn_to_ascii_range(uint offset, uint length) {
   uchar *retval = (uchar *) malloc(length);

   if(retval == NULL)
      return NULL;

   for(uint i = 0 ; i < length; i ++) {
      retval[i] = pkmn_to_ascii_char(save_file[offset + i]);
      if(save_file[offset+i] == 0x50) {
         retval[i] = '\0';
         break;
      }
   }

   return retval;
}
{% endhighlight %}

All we have to do is read the bytes from out of the save file, create the string, and return it.  Nothing's particularly hard about that, so long as we remember to null-terminate our string, since we're creating it ourselves.  To implement the conversion table, all it takes is a `switch` statement for the characters that aren't a direct ASCII conversion.  I won't reproduce the entire sordid thing here, since it's fairly long, but it's pretty clear-cut:

{% highlight c++ %}
uchar pkmn_to_ascii_char(uchar pkmn_char) {
   int value = 0;
   switch(pkmn_char) {
      case 0x00: case 0x50:
         value = '\0';
         break;
      case 0x7f:
         value = ' ';
         break;
      // boring cases elided
      case 0xe1:  // (PK) symbol
         value = '@';
         break;
      case 0xe2:  // (MN) symbol
         value = '#';
         break;
      case 0xe8: case 0xf2:
         value = '.';
         break;
      case 0xef:  // Mars (male) symbol
         value = '&';
         break;
      // more boring cases elided
      case 0xf5:  // Venus (female) symbol
         value = '*';
         break;
      default:
         if(lies_between(pkmn_char, 0xf6, 0xff, true)) {
            value = (uchar) (pkmn_char - 0xc6);
         } else if(lies_between(pkmn_char, 0x80, 0x99, true) or 
                   lies_between(pkmn_char, 0xa0, 0xb9, true)) {
            value = (uchar) (pkmn_char - 0x3f);
         }
   }

   return value;
}
{% endhighlight %}

The `lies_between` method is simply shorthand for testing whether a given value lies between the given bounds; in C++, we can write this as an `inline` method for a speed boost.  So that I don't have to resort to using wide characters, I opt to use false characters for things not in the character set.[^1]

[^1]: If I were writing this in Ruby, I could do everything as single-length strings and use `split` and `join`.